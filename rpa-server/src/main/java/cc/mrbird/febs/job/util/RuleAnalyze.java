package cc.mrbird.febs.job.utils;


import lombok.Data;

import java.util.ArrayList;
import java.util.List;

import static cc.mrbird.febs.job.configure.SimpleConfigs.Flag;
import static cc.mrbird.febs.job.configure.WordMap.keyvaluesMap;

public class RuleAnalyze {

    public static void main(String args[]){

        String word="明朝年间，燕王朱棣车主靖难之役，率军攻打济南时，遭到了守将盛庸的抵抗，久攻不下，还在东昌府遭到伏击，朱棣差一点丧命乱军之中。他恨恨地对手下将士说：“有朝一日打下东昌府，我要在这里屠城三日！”再出兵时，朱棣采取了稳扎稳打的战术，最终打下了济南，随后占领了整个山东，东昌府自然也被打了下来。庆功宴上，朱棣眼露凶光地说：“我说过，占领东昌府后要屠城三日，绝不能食言！”将士们听了，都大吃一惊，若是真的屠城，岂不失了民心？有人大着胆子劝朱棣收回成命，没想到他是吃了秤砣铁了心，不管谁来劝说，都被臭骂一顿。庆功宴的气氛变得很是压抑。朱棣手下有个大将，名叫顾成。见众人一时无法说服朱棣，他上前一步，说：“王爷，末将斗胆提出一个请求，还望王爷恩准。”朱棣不耐烦地说：“要是想让我改变主意，就省省吧！”顾成连忙说：“末将不敢，只是当年末将曾路过这里，被强人拦截，多亏此地百姓出手相助，末将才捡回一条性命。救命之恩，一直未能报答，因此末将想在屠城时留出一片安全之地，哪怕只给一箭之地，末将也好跟人交代，不枉了当年的恩情。”朱棣一听，爽快地说：“这面子我肯定给。”说完，他“嘿嘿”一笑，说，“顾将军，还望你准备好强弓硬弩，能射多远就射多远！”顾成谢过朱棣，重新回到了座位上。第二天，将士们早早就来到了东昌府的一条大街上，都想看个稀罕。大伙心中暗想，顾成这一箭大不了射出去几百步远，也只能救下几十户人家罢了，这根本就无济于事啊！正想着呢，就见朱棣骑着马，在侍卫们的簇拥下也来到了这里。他扫视了一下众将，高声问道：“顾成到了吗？”顾成早就到了，他忙在马背上躬身施礼，说：“王爷，末将在！”朱棣板着脸说：“顾将军，准备好了吧？”顾成点了点头：“一切准备就绪。”朱棣说：“既然如此，你有多大力气就用多大力气，能射多远就射多远，我保这一箭之地内的百姓无恙，绝不食言。”顾成答应一声，拨转马头，摘下宝雕弓，从箭囊里抽出一支狼牙箭，正准备搭弓放箭，朱棣突然说道：“慢着！”朱棣带着侍卫来到顾成近前，说：“顾将军，咱先小人后君子，你这一箭射出去，到底远近多少，得找人做个见证。”顾成说：“还是王爷想得周全，找谁来做见证，那就请王爷定夺吧。”朱棣也不推辞，他看了看旁边的侍卫胡濙，说：“胡濙，就由你来做这个见证吧。”胡濙答应一声，一抖缰绳，马向前走了几步，在街边立定。一切准备妥当，顾成重新弯弓搭箭，他手中的箭还没射出，突然，胡濙的马不知受了什么刺激，一声嘶鸣，猛地向前冲去，眨眼工夫就跑出去百十步远。说时迟那时快，顾成的箭跟着射出，只见那箭势若流星，疾飞向前，恰好射在马尾巴上，狼牙箭的倒钩挂住了马尾，没有落地。带着箭的这匹马像发了疯似的飞奔，转眼就跑没影了。这下可把众人给闹愣了，就连朱棣也惊得目瞪口呆。过了好大一会儿，胡濙才骑着马跑了回来，只见他满脸是汗，来到朱棣面前，还没有说话，那支挂在马尾巴上的箭“啪嗒”一声，掉在了地上。朱棣冷着脸问：“胡濙，你这是怎么回事？”胡濙心中一凛，回答说：“王爷，都怪卑职未能管束好自己的马，请王爷重重责罚。”朱棣把手一摆，说：“算了算了，你说说马跑了多远吧。”胡濙战战兢兢地说：“绕着东昌府跑了一圈。”朱棣问：“你说的可是实话？”胡濙回答：“卑职不敢说半点瞎话。”朱棣听罢，对顾成说：“顾将军，这是天意啊！既然如此，我只能收回成命。”顾成赶紧翻身下马，跪在地上说：“王爷英明！”旁边的将士们一看，也跟着下了马，山呼“王爷英明”。这件事传开后，东昌府的百姓们对顾成感恩戴德，甚至还给他立了生祠。后来，朱棣率军打下南京，登上皇位，被后世称为明成祖。顾成也因为战功被派往贵州驻守，成为一方诸侯。有老友就当年一箭之地的事儿问顾成，是不是真的那么巧，顧成捋须反问道：“你说呢？”其实，很多事情根本不是巧合，而是出于人为。原来，当年朱棣经过一夜思考，也觉得不该屠城，但碍于面子，又不能直接收回成命。幸亏前一天顾成提出了一箭之地的请求，给了朱棣机会，于是他安排好了胡濙。胡濙的马尾被提前盘了几条辫子。顾成准备射箭的时候，胡濙用手中的剑柄戳了一下马屁股，马这才跑了出去。善于察言观色的顾成瞅准机会，射出了这支“巧合”的箭。喂嗯您好，这边是武汉路泽捷豹路虎4S店的，请问您是AUF149的车主吗？对。啊先生不好意思，抱歉打扰到您这边的话呢是根据我们的系统提示，您的这辆车的话，近期的话需要嗯回厂进行一个常规的保养，您看您最近有没有时间回查呀。嗯这个我知道，另外你帮我查一下，我那边还有没有那个维修圈的。嗯行，那这边的话我先帮您查一下，好吧？稍后我再给您回个电话，因为这个。打一下我之前充值的那个圈，还有还有我之前买保险送的那个保安状况，这个有没有，你帮我查一下好吧？好的好的，那您稍等！是充值送的，一次好像是我买的保险好像也送了，但是我送了。维修好像不知道是宝马还是谁帮你照看一下，看一下，待会回给我好吧？嗯好的，行，那我查了之后我给您回个电话。好好，谢谢嗯好的，不客气！了，那就不打扰您了，唉，祝您生活愉快，再见好好！";

//        String rule="(((\"武汉\" AND \"车主\" ) AND (\"不好意思\" OR \"关键字5\")) AND ((\"武汉\" NEAR#5 \"捷豹\") AND (\"抱歉\" AFTER#5 \"到您\"))) AND (\"回厂\" BEFORE#5 \"需要\") AND (\"帮我\" OR \"关键字6\")";
        String rule="车主";
        long a = System.currentTimeMillis();
        boolean value = main_function(word,rule.replaceAll("\"",""));
        System.out.println("value===="+value);
        System.out.println("-----need time hotevent:" + (System.currentTimeMillis() - a));
//
//        if (Flag) System.out.println("value -===================="+value);
    }

    public static boolean main_function(String word,String _rule){
        //获取短文列表和连接符
        Datas data = getDataInfo(_rule);
        //存放每个短文的结果
        List<Boolean> result = new ArrayList<>();
        //获取短文列表中的每个结果
        if (Flag) System.out.println("data.list================================="+data.list);
        for(String content : data.list){
            if(isShort(content))
                result.add(processShortContent(word,content));
            else
                result.add(main_function(word,content));
        }
//        System.out.println("result============================"+result);
        /**
         * 如果是and，只要有一个不满足就直接返回false
         */
        if (data.list.size()>1){
            if(data.keyword.equals(" AND ")){
                for(Boolean b : result )
                    if(!b)
                        return false;
                return true;
            }

            /**
             * 如果是or，只要有一个就返回true
             */
            if(data.keyword.equals(" OR ")){
                for(Boolean b : result )
                    if(b)
                        return true;
                return false;
            }
        }else {
            for(Boolean b : result )
                if(b)
                    return true;
            return false;

        }


        return false;
    }

    /**
     * 最小单位的短文，进行5选1的判断操作
     * @param _rule
     * @return
     */
    public static boolean processShortContent(String word,String _rule){
        return rule_str(word,_rule);
    }

    /**
     * 判断短文是否是最小单位
     * @param _rule
     * @return
     */
    public static boolean isShort(String _rule){
        if (!_rule.contains("(") && !_rule.contains(")"))
            return true;
        else
            return false;
    }

    /**
     * 获取文本分成短文列表和连接符
     * @param _aString
     * @return
     */
    public static Datas getDataInfo(String _aString){

        //截取字符串的开始位置,每截取一次都要后移
        int index = 0;
        //记录括号数量，左+1，右-1
        int bracketCount = 0;
        //运算符的运算成员列表
        List<String> list = new ArrayList<>();
        //运算符
        String operator = null;

        for(int i=0; i<_aString.length(); i++){
            //左括号+1
            if(_aString.charAt(i) == '(') {
                bracketCount += 1;
            }
            //右括号-1
            if(_aString.charAt(i) == ')') {
                bracketCount -= 1;
                if(bracketCount==0){
                    //将一组条件保存下来
                    list.add(_aString.substring(index+1,i));
                    //最后一条件后不会有运算符
                    if(i < _aString.length()-1) {
                        operator = _aString.substring(i + 1, i + 6);
                        if (operator.indexOf("OR") > -1)
                            operator = " OR ";
                        else if (operator.indexOf("AND") > -1)
                            operator = " AND ";
                        //为下次获取条件去掉前面的运算符
                        index = i + 1 + operator.length();
                    }else{
                        //循环结束
                        break;
                    }
                }
            }
        }

        Datas data = new Datas();
        data.setList(list);
        data.setKeyword(operator);
        return data;
    }


    /**
     * 把文本_rule中的words，全部换成_name
     * @param _name
     * @return
     */
    public static String replaceContent(String _name){
        if (keyvaluesMap.containsKey(_name)) {
            if (Flag) System.out.println("map.value============================"+keyvaluesMap.get(_name).replace(",", "|"));
            return  keyvaluesMap.get(_name).replace(",", "|");
        }else
            return _name;
    }

    @Data
    public static class Datas{
        String keyword;
        List<String> list;
    }

    private static int[] analysisBrackets(String str){
        int stack = 0;
        int metaStart = -1;
        int charStart = 0;
        int charEnd = 0;
        while (++metaStart < str.length()) {
            char c = str.charAt(metaStart);
            //System.out.println("c: "+c);
            if (c == '(') {
                if (stack == 0) {
                    charStart = metaStart;
                }
                stack++;
            } else if (c == ')') {
                stack--;
                if (stack == 0) {
                    charEnd = metaStart;
                    break;
                }
            }
        }
        return new int[]{charStart,charEnd};
    }


    public  static List<Integer> searchindex(String word,String str){
        List<Integer> list = new ArrayList<>();
        int a = word.indexOf(str);
        while (a !=-1){
            list.add(a);
            a = word.indexOf(str,a+1);
        }
        return list;
    }

    public static boolean rule_str(String word,String str) {
        long a = System.currentTimeMillis();
        boolean returnFlag = false;
        if (str.contains("AND")) {
            List<Boolean> ll = new ArrayList<>();
            String[] keystr = str.split("AND");

            for (int i = 0; i <= keystr.length-1; i++) {
                str = word.replaceAll(replaceContent(keystr[i].trim()), keystr[i].trim());
                if (str.contains(keystr[i].trim()))
                    ll.add(true);
                else
                    ll.add(false);
            }
            if (ll.contains(false))
                    returnFlag= false;
                else
                    returnFlag= true;

        } else if (str.contains("BEFORE")) {
            String[] keystr = str.split(" ");
            Integer distance = Integer.parseInt(keystr[1].split("#")[1]);
            Integer head = 0;
            String str1 = word.replaceAll(replaceContent(keystr[0].trim()), keystr[0].trim()).replaceAll(replaceContent(keystr[2].trim()), keystr[2].trim());
            if (Flag) System.out.println("str1 =========================" + str1);
            if (str1.contains(keystr[0].trim())) {
                List<Integer> keyList = searchindex(str1, keystr[0].trim());
                for (Integer start : keyList) {
                    if (start - distance < 0) {
                        head = 0;
                    } else {
                        head = start - distance;
                    }
                    returnFlag = str1.substring(head, start).contains(keystr[2].trim());
                    if (returnFlag == true) {
                        System.out.println("-----BEFORE消耗时间" + (System.currentTimeMillis() - a));
                        return true;
                    }
                }
            }
        } else if (str.contains("NEAR")) {
            String[] keystr = str.trim().split(" ");
            Integer distance = Integer.parseInt(keystr[1].split("#")[1]);
            Integer head = 0;
            Integer tail = 0;
            String str1 = word.replaceAll(replaceContent(keystr[0].trim()), keystr[0].trim()).replaceAll(replaceContent(keystr[2].trim()), keystr[2].trim());
            if (Flag) System.out.println("str1=========================" + str1);
            if (str1.contains(keystr[0].trim())) {
                List<Integer> keyList = searchindex(str1, keystr[0].trim());
                for (Integer start : keyList) {
                    if (start - distance < 0) {
                        head = 0;
                    } else {
                        head = start - distance;
                    }
                    if (start + distance >= str1.length()) {
                        tail = str1.length();
                    } else {
                        tail = start + distance;
                    }
                    System.out.println("str1============:"+str1.length());
                    System.out.println("head============:"+head);
                    System.out.println("tail============:"+tail);
                    returnFlag = str1.substring(head, tail).contains(keystr[2].trim());
                    if (returnFlag == true) {
                      if (Flag) System.out.println("-----NEAR消耗时间：" + (System.currentTimeMillis() - a));
                        return true;
                    }
                }
            }
        } else if (str.contains("AFTER")) {
            String[] keystr = str.split(" ");
            Integer distance = Integer.parseInt(keystr[1].split("#")[1]);
            Integer tail = 0;
            String str1 = word.replaceAll(replaceContent(keystr[0].trim()), keystr[0].trim()).replaceAll(replaceContent(keystr[2].trim()), keystr[2].trim());
            if (Flag) System.out.println("str1=========================" + str1);
            if (str1.contains(keystr[0].trim())) {
                List<Integer> keyList = searchindex(str1, keystr[0].trim());
                for (Integer start : keyList) {

                    if (start + distance >= str1.length()) {
                        tail = str1.length();
                    } else {
                        tail = start + distance;
                    }
                    returnFlag = str1.substring(start, tail).contains(keystr[2].trim());
                    if (returnFlag == true) {
                        System.out.println("-----AFTER消耗时间：" + (System.currentTimeMillis() - a));
                        return true;
                    }
                }
            }
        } else if (str.contains("OR")) {
            List<Boolean> ll = new ArrayList<>();
            String[] keystr = str.split("OR");

            for (int i = 0; i <= keystr.length-1; i++) {
                str = word.replaceAll(replaceContent(keystr[i].trim()), keystr[i].trim());
                if (str.contains(keystr[i].trim()))
                    ll.add(true);
                else
                    ll.add(false);
            }
            if (ll.contains(true))
                returnFlag= true;
            else
                returnFlag= false;

        }else {
            if (word.replaceAll(replaceContent(str),str).contains(str))
                returnFlag=true;
            else
                returnFlag=false;
        }
        return returnFlag;
    }


    public static boolean OneRule(String word,String _rule ){
      boolean returnFlag =false;
      if (word.replaceAll(replaceContent(_rule),_rule).contains(_rule))
        returnFlag=true;
      else
        returnFlag=false;
      return returnFlag;
    }

}
